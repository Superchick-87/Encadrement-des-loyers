<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Carte interactive - Encadrement-des-loyers</title>
  <link rel="stylesheet" href="css/style.css">
</head>

<body>
  <select id="zoneSelect">
    <option value="" selected disabled>Choisissez une zone</option>
    <option value="Zone_1">Zone 1</option>
    <option value="Zone_2">Zone 2</option>
    <option value="Zone_3">Zone 3</option>
    <option value="Zone_4">Zone 4</option>
    <option value="Zone_5">Zone 5</option>
  </select>

  <div class="zoom-controls">
    <button id="zoomIn">+</button>
    <button id="zoomOut">‚àí</button>
    <button id="resetZoom">‚ü≥</button>
  </div>

  <div class="svg-container" id="svgContainer"></div>
  <div id="intro">
    <p id="legend" class="legend">
      Le zonage refl√®te l'influence de la localisation sur le niveau des loyers.
      Il r√©sulte d'un travail √©conom√©trique permettant d'isoler l'incidence
      de la localisation, parmi les diff√©rents facteurs qui influencent
      le niveau des loyers (taille du logement, √©poque de construction, type d'habitat...)
    </p>
    <h3>Les locations dans l'agglom√©ration de Bordeaux selon le type de logement</h3>
    <img class="imageIntro" src="images/visu_intro.png" alt="Visuel accueil">
    <div id="intro-container" class="intro-container">
      <div>
        <img class="intro-container-img" src="images/ensemble.png" alt="">
        <p class="intro-type">Ensemble</p>
        <div class="intro-bloc-chiffres">
          <div>
            <p class="intro-chiffres">724 ‚Ç¨</p>
            <p class="intro-chiffres-legend">Loyer</p>
          </div>
          <div>
            <p class="intro-chiffres">59 m¬≤</p>
            <p class="intro-chiffres-legend">Surface</p>
          </div>
        </div>
      </div>

      <div>
        <img class="intro-container-img" src="images/maisons.png" alt="">
        <p class="intro-type">Maisons</p>
        <div class="intro-bloc-chiffres">
          <div>
            <p class="intro-chiffres">995 ‚Ç¨</p>
            <p class="intro-chiffres-legend">Loyer</p>
          </div>
          <div>
            <p class="intro-chiffres">89 m¬≤</p>
            <p class="intro-chiffres-legend">Surface</p>
          </div>
        </div>
      </div>

      <div>
        <img class="intro-container-img" src="images/appartements.png" alt="">
        <p class="intro-type">Appartements</p>
        <div class="intro-bloc-chiffres">
          <div>
            <p class="intro-chiffres">662 ‚Ç¨</p>
            <p class="intro-chiffres-legend">Loyer</p>
          </div>
          <div>
            <p class="intro-chiffres">52 m¬≤</p>
            <p class="intro-chiffres-legend">Surface</p>
          </div>
        </div>
      </div>

    </div>
  </div>

  <div id="zoneData"></div>
  <footer></footer>
  <script>
    /* -------------------------------------------------------------------------- */
    /* üß≠ VARIABLES GLOBALES & √âL√âMENTS PRINCIPAUX                                */
    /* -------------------------------------------------------------------------- */

    const container = document.getElementById('svgContainer'); // Conteneur principal du SVG
    const select = document.getElementById('zoneSelect');   // Menu d√©roulant de s√©lection
    const zoneDataDiv = document.getElementById('zoneData');     // Zone d‚Äôaffichage des donn√©es
    let svgInteractive, svgOverlay;                                // Les deux calques SVG
    let originalViewBox;                                           // ViewBox initiale pour reset zoom
    let zoneStats = null;                                          // Donn√©es JSON des zones

    /* -------------------------------------------------------------------------- */
    /* üé® CONVERTISSEUR DE COULEURS ‚Üí RGBA                                        */
    /* -------------------------------------------------------------------------- */
    // Convertit une couleur CSS (hex ou rgb) en rgba avec opacit√© personnalis√©e.
    // Exemple : colorToRgba('#FF0000', 0.3) ‚Üí 'rgba(255,0,0,0.3)'
    function colorToRgba(color, opacity = 0.2) {
      if (color.startsWith("rgba")) {
        return color.replace(/[\d.]+\)$/g, opacity + ")");
      }
      if (color.startsWith("rgb(")) {
        const parts = color.match(/\d+/g);
        return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${opacity})`;
      }
      if (color.startsWith("#")) {
        let r, g, b;
        if (color.length === 4) { // Format court (#FFF)
          r = parseInt(color[1] + color[1], 16);
          g = parseInt(color[2] + color[2], 16);
          b = parseInt(color[3] + color[3], 16);
        } else { // Format long (#FFFFFF)
          r = parseInt(color.substr(1, 2), 16);
          g = parseInt(color.substr(3, 2), 16);
          b = parseInt(color.substr(5, 2), 16);
        }
        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
      }
      return `rgba(0,0,0,${opacity})`; // Couleur par d√©faut : noir
    }

    /* -------------------------------------------------------------------------- */
    /* üó∫Ô∏è CHARGEMENT DES CARTES SVG                                               */
    /* -------------------------------------------------------------------------- */
    Promise.all([
      fetch('images/zone-test.svg').then(res => res.text()),   // Carte principale
      fetch('images/Agglo.svg').then(res => res.text())        // Calque de superposition
    ]).then(([zoneText, overlayText]) => {
      container.innerHTML = zoneText + overlayText;
      svgInteractive = container.querySelector('svg:first-of-type');
      svgOverlay = container.querySelector('svg:last-of-type');
      originalViewBox = svgInteractive.getAttribute('viewBox').split(' ').map(Number);
      svgOverlay.style.pointerEvents = 'none';                 // D√©sactive les clics sur la couche Agglo

      setupInteractions(svgInteractive);                       // Active les clics sur les zones
      setupZoom(svgInteractive, svgOverlay);                   // Active le zoom
      setupDrag(svgInteractive, svgOverlay);                   // Active le d√©placement
      loadZoneData();                                          // Charge le JSON de donn√©es
    });

    /* -------------------------------------------------------------------------- */
    /* üñ±Ô∏è INTERACTIONS SUR LES ZONES                                              */
    /* -------------------------------------------------------------------------- */
    function setupInteractions(svgRoot) {
      const zones = svgRoot.querySelectorAll('g[id^="Zone_"]'); // Toutes les zones identifi√©es

      // --- Fonction de s√©lection d‚Äôune zone ---
      function handleZoneSelection(zone) {
        const isSelected = zone.classList.contains('highlight');
        if (!isSelected) {
          // On att√©nue toutes les zones sauf celle s√©lectionn√©e
          zones.forEach(z => { z.classList.remove('highlight'); z.classList.add('dimmed'); });
          zone.parentNode.appendChild(zone);                    // La zone passe au premier plan
          zone.classList.add('highlight');
          zone.classList.remove('dimmed');
          select.value = zone.id;                               // Synchronisation avec le menu
        } else {
          zones.forEach(z => z.classList.remove('highlight', 'dimmed'));
          select.value = "";
        }
        updateZoneData(select.value);                           // Rafra√Æchit les infos affich√©es
      }

      // --- Gestion clics & tap tactile sur chaque zone ---
      zones.forEach(zone => {
        zone.addEventListener('click', () => handleZoneSelection(zone));
        zone.addEventListener('touchstart', e => {
          e.preventDefault();                                   // Emp√™che le scroll pendant le tap
          handleZoneSelection(zone);
        }, { passive: false });
      });

      // --- Gestion via le menu d√©roulant ---
      select.addEventListener('change', () => {
        const val = select.value;
        zones.forEach(z => z.classList.remove('highlight', 'dimmed'));
        if (val) {
          const selZone = svgRoot.querySelector('#' + val);
          selZone.classList.add('highlight');
          zones.forEach(z => { if (z !== selZone) z.classList.add('dimmed'); });
          selZone.parentNode.appendChild(selZone);
        }
        updateZoneData(val);
      });
    }

    /* -------------------------------------------------------------------------- */
    /* üîç GESTION DU ZOOM                                                         */
    /* -------------------------------------------------------------------------- */
    function setupZoom(svgRoot, overlay) {
      const zoomFactor = 1.2; // Facteur de zoom (20%)

      // --- Fonction utilitaire de zoom ---
      const zoom = (factor) => {
        let [x, y, w, h] = svgRoot.getAttribute('viewBox').split(' ').map(Number);
        const newW = w / factor;
        const newH = h / factor;
        const newX = x + (w - newW) / 2;
        const newY = y + (h - newH) / 2;
        const vb = `${newX} ${newY} ${newW} ${newH}`;
        svgRoot.setAttribute('viewBox', vb);
        overlay.setAttribute('viewBox', vb);
      };

      // --- Boutons +, -, reset ---
      document.getElementById('zoomIn').addEventListener('click', () => zoom(zoomFactor));
      document.getElementById('zoomOut').addEventListener('click', () => zoom(1 / zoomFactor));
      document.getElementById('resetZoom').addEventListener('click', () => {
        const vb = originalViewBox.join(' ');
        svgRoot.setAttribute('viewBox', vb);
        overlay.setAttribute('viewBox', vb);
      });

      // --- Zoom √† la molette ---
      container.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;
        zoom(factor);
      });
    }

    /* -------------------------------------------------------------------------- */
    /* ‚úã GESTION DU D√âPLACEMENT (DRAG)                                           */
    /* -------------------------------------------------------------------------- */
    function setupDrag(svgRoot, overlay) {
      let isDragging = false, startX, startY, viewBox;

      // R√©cup√®re les coordonn√©es (compatible souris & tactile)
      const getCoords = (e) => {
        if (e.touches && e.touches.length)
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        return { x: e.clientX, y: e.clientY };
      };

      // --- D√©but du drag ---
      const startDrag = (e) => {
        isDragging = true;
        const { x, y } = getCoords(e);
        startX = x;
        startY = y;
        viewBox = svgRoot.getAttribute('viewBox').split(' ').map(Number);
        container.style.cursor = 'grabbing';
        e.preventDefault();
      };

      // --- Pendant le drag ---
      const duringDrag = (e) => {
        if (!isDragging) return;
        const { x, y } = getCoords(e);
        const dx = (startX - x) * (viewBox[2] / container.clientWidth);
        const dy = (startY - y) * (viewBox[3] / container.clientHeight);
        const vb = `${viewBox[0] + dx} ${viewBox[1] + dy} ${viewBox[2]} ${viewBox[3]}`;
        svgRoot.setAttribute('viewBox', vb);
        overlay.setAttribute('viewBox', vb);
      };

      // --- Fin du drag ---
      const endDrag = () => {
        if (isDragging) {
          isDragging = false;
          container.style.cursor = 'grab';
        }
      };

      // --- √âv√©nements souris ---
      container.addEventListener('mousedown', startDrag);
      window.addEventListener('mousemove', duringDrag);
      window.addEventListener('mouseup', endDrag);

      // --- √âv√©nements tactiles ---
      container.addEventListener('touchstart', startDrag, { passive: false });
      window.addEventListener('touchmove', duringDrag, { passive: false });
      window.addEventListener('touchend', endDrag);
    }

    /* -------------------------------------------------------------------------- */
    /* üì¶ CHARGEMENT DES DONN√âES JSON                                             */
    /* -------------------------------------------------------------------------- */
    function loadZoneData() {
      fetch('datas/datas.json')
        .then(res => res.json())
        .then(data => { zoneStats = data.zones; });
    }

    /* -------------------------------------------------------------------------- */
    /* üß© AFFICHAGE DES DONN√âES PAR ZONE                                          */
    /* -------------------------------------------------------------------------- */
    function updateZoneData(zoneId) {
      // Si aucune zone s√©lectionn√©e ‚Üí on vide l‚Äôaffichage
      if (!zoneStats || !zoneId) {
        zoneDataDiv.innerHTML = '';
        updateIntroVisibility();
        return;
      }

      const zone = zoneStats.find(z => z.id === zoneId);
      if (!zone) return;

      // Couleur de fond li√©e √† la zone (pour coh√©rence visuelle)
      const polygon = svgInteractive.querySelector(`#${zone.id} polygon`);
      const color = polygon ? window.getComputedStyle(polygon).getPropertyValue('fill') : '#000';
      const colorOpacity = colorToRgba(color, 0.2);

      const zoneGroup = document.createElement('div');
      zoneGroup.className = 'zone-group';

      // --- Titre color√© ---
      const h3 = document.createElement('h3');
      h3.textContent = zone.nom;
      h3.style.backgroundColor = color;
      h3.style.color = 'white';
      zoneGroup.appendChild(h3);

      // --- Liste des cartes de donn√©es ---
      const cardsDiv = document.createElement('div');
      cardsDiv.className = 'zone-cards';

      zone.categories.forEach((c, index) => {
        const card = document.createElement('div');
        card.className = 'zone-card';
        card.style.backgroundColor = colorOpacity;
        card.style.opacity = 0;
        card.style.transform = 'translateY(20px)';
        card.style.transition = 'opacity 0.4s ease, transform 0.4s ease';

        // Nom de fichier image d√©riv√© de la cat√©gorie
        const imageName = c.categorie
          .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
          .toLowerCase().replace(/\s+/g, '');

        const img = document.createElement('img');
        img.src = `images/${imageName}.png`;
        img.alt = c.categorie;
        img.onerror = () => img.src = 'images/default.png'; // Image fallback

        const content = document.createElement('div');
        content.className = 'zone-card-content';
        content.innerHTML = `
        <h4>${c.categorie}</h4>
        <p><strong>Loyer m√©dian :</strong> ${c.loyer_median} ‚Ç¨/m¬≤</p>
        <p><strong>Loyer moyen :</strong> ${c.loyer_moyen} ‚Ç¨/m¬≤</p>
        <p><strong>Surface moyenne :</strong> ${c.surface_habitable_moyenne} m¬≤</p>
        <p><strong>Logements enqu√™t√©s :</strong> ${c.nombre_logements}</p>
      `;

        card.appendChild(img);
        card.appendChild(content);
        cardsDiv.appendChild(card);

        // Animation d‚Äôapparition progressive
        setTimeout(() => {
          card.style.opacity = 1;
          card.style.transform = 'translateY(0)';
        }, 100 * index);
      });

      zoneGroup.appendChild(cardsDiv);
      zoneDataDiv.innerHTML = '';
      zoneDataDiv.appendChild(zoneGroup);
      updateIntroVisibility();
    }

    /* -------------------------------------------------------------------------- */
    /* üëã AFFICHAGE / MASQUAGE DU BLOC INTRO                                      */
    /* -------------------------------------------------------------------------- */
    function updateIntroVisibility() {
      const intro = document.getElementById('intro');
      const zoneData = document.getElementById('zoneData');
      if (!intro || !zoneData) return;

      // Si aucune donn√©e affich√©e ‚Üí on montre le bloc d‚Äôintro
      intro.style.display = zoneData.innerHTML.trim() === '' ? 'block' : 'none';
    }
  </script>



</body>

</html>